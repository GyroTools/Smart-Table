{"version":3,"sources":["smart-table.min.js"],"names":["ng","undefined","module","run","$templateCache","put","constant","pagination","template","itemsByPage","displayedPages","search","delay","inputEvent","select","mode","selectedClass","sort","ascentClass","descentClass","descendingFirst","skipNatural","pipe","controller","$scope","$parse","$filter","$attrs","copyRefs","src","concat","updateSafeCopy","safeCopy","safeGetter","pipeAfterSafeCopy","ctrl","deepDelete","object","path","indexOf","partials","split","key","pop","parentPath","join","parentObject","Object","keys","length","filtered","lastSelected","propertyName","stTable","displayGetter","displaySetter","assign","orderBy","filter","tableState","start","totalItemCount","this","stSafeSrc","$watch","safeSrc","newValue","oldValue","sortBy","predicate","reverse","isFunction","functionName","name","input","predicateObject","prop","isString","trim","output","selectAll","number","numberOfPages","Math","ceil","slice","parseInt","row","shiftSelect","index","lastIndex","rows","state","isSelected","min","max","i","multiSelect","getFilteredCollection","setFilterFunction","filterName","setSortFunction","sortFunctionName","preventPipeOnWatch","directive","restrict","link","scope","element","attr","stSetFilter","stSetSort","stConfig","$timeout","require","tableCtrl","promise","throttle","stDelay","event","stInputEvent","$observe","value","predicateExpression","stSearch","bind","evt","originalEvent","cancel","target","stSelectMode","$event","$apply","shiftKey","ctrlKey","addClass","removeClass","stopPropagation","func","getter","isArray","stSort","sortDefault","classAscent","stClassAscent","classDescent","stClassDescent","stateClasses","stSkipNatural","stDescendingFirst","stSortDefault","$eval","stItemsByPage","stDisplayedPages","stPageChange","templateUrl","attrs","stTemplate","redraw","end","paginationState","prevPage","currentPage","floor","abs","pages","numPages","push","newPage","selectPage","page","config","stPipe","pre","pipePromise","post","angular"],"mappings":"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","file":"smart-table.min.js","sourcesContent":["(function (ng, undefined){\r\n    'use strict';\r\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\r\n    $templateCache.put('template/smart-table/pagination.html',\r\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\r\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"javascript: void(0);\" ng-click=\"selectPage(page)\">{{page}}</a></li>' +\r\n        '</ul></nav>');\r\n}]);\r\n\r\n\nng.module('smart-table')\r\n  .constant('stConfig', {\r\n    pagination: {\r\n      template: 'template/smart-table/pagination.html',\r\n      itemsByPage: 10,\r\n      displayedPages: 5\r\n    },\r\n    search: {\r\n      delay: 400, // ms\r\n      inputEvent: 'input'\r\n    },\r\n    select: {\r\n      mode: 'single',\r\n      selectedClass: 'st-selected'\r\n    },\r\n    sort: {\r\n      ascentClass: 'st-sort-ascent',\r\n      descentClass: 'st-sort-descent',\r\n      descendingFirst: false,\r\n      skipNatural: false,\r\n      delay:300\r\n    },\r\n    pipe: {\r\n      delay: 100 //ms\r\n    }\r\n  });\nng.module('smart-table')\r\n  .controller('stTableController', ['$scope', '$parse', '$filter', '$attrs', function StTableController ($scope, $parse, $filter, $attrs) {\r\n    var propertyName = $attrs.stTable;\r\n    var displayGetter = $parse(propertyName);\r\n    var displaySetter = displayGetter.assign;\r\n    var safeGetter;\r\n    var orderBy = $filter('orderBy');\r\n    var filter = $filter('filter');\r\n    var safeCopy = copyRefs(displayGetter($scope));\r\n    var tableState = {\r\n      sort: {},\r\n      search: {},\r\n      pagination: {\r\n        start: 0,\r\n        totalItemCount: 0\r\n      }\r\n    };\r\n    var filtered;\r\n    var pipeAfterSafeCopy = true;\r\n    var ctrl = this;\r\n    /** the last row that has been selected (or unselected) */\r\n    var lastSelected;\r\n\r\n    function copyRefs (src) {\r\n      return src ? [].concat(src) : [];\r\n    }\r\n\r\n    function updateSafeCopy () {\r\n      safeCopy = copyRefs(safeGetter($scope));\r\n      if (pipeAfterSafeCopy === true) {\r\n        ctrl.pipe();\r\n      }\r\n    }\r\n\r\n    function deepDelete (object, path) {\r\n      if (path.indexOf('.') != -1) {\r\n        var partials = path.split('.');\r\n        var key = partials.pop();\r\n        var parentPath = partials.join('.');\r\n        var parentObject = $parse(parentPath)(object)\r\n        delete parentObject[key];\r\n        if (Object.keys(parentObject).length == 0) {\r\n          deepDelete(object, parentPath);\r\n        }\r\n      } else {\r\n        delete object[path];\r\n      }\r\n    }\r\n\r\n    if ($attrs.stSafeSrc) {\r\n      safeGetter = $parse($attrs.stSafeSrc);\r\n      $scope.$watch(function () {\r\n        var safeSrc = safeGetter($scope);\r\n        return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\r\n      }, function (newValue, oldValue) {\r\n        if (newValue !== oldValue) {\r\n          updateSafeCopy();\r\n        }\r\n      });\r\n      $scope.$watch(function () {\r\n        var safeSrc = safeGetter($scope);\r\n        return safeSrc ? safeSrc.length : 0;\r\n      }, function (newValue, oldValue) {\r\n        if (newValue !== safeCopy.length) {\r\n          updateSafeCopy();\r\n        }\r\n      });\r\n      $scope.$watch(function () {\r\n        return safeGetter($scope);\r\n      }, function (newValue, oldValue) {\r\n        if (newValue !== oldValue) {\r\n          tableState.pagination.start = 0;\r\n          updateSafeCopy();\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * sort the rows\r\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\r\n     * @param [reverse] - if you want to reverse the order\r\n     */\r\n    this.sortBy = function sortBy (predicate, reverse) {\r\n      tableState.sort.predicate = predicate;\r\n      tableState.sort.reverse = reverse === true;\r\n\r\n      if (ng.isFunction(predicate)) {\r\n        tableState.sort.functionName = predicate.name;\r\n      } else {\r\n        delete tableState.sort.functionName;\r\n      }\r\n\r\n      tableState.pagination.start = 0;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * search matching rows\r\n     * @param {String} input - the input string\r\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\r\n     */\r\n    this.search = function search (input, predicate) {\r\n      var predicateObject = tableState.search.predicateObject || {};\r\n      var prop = predicate ? predicate : '$';\r\n\r\n      input = ng.isString(input) ? input.trim() : input;\r\n      $parse(prop).assign(predicateObject, input);\r\n      // to avoid to filter out null value\r\n      if (!input) {\r\n        deepDelete(predicateObject, prop);\r\n      }\r\n      tableState.search.predicateObject = predicateObject;\r\n      tableState.pagination.start = 0;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\r\n     */\r\n    this.pipe = function pipe () {\r\n      var pagination = tableState.pagination;\r\n      var output;\r\n      if(lastSelected) //if selection has been used, clear all selections\r\n    \t  this.selectAll(safeCopy, false);\r\n      filtered = tableState.search.predicateObject ? filter(safeCopy, tableState.search.predicateObject) : safeCopy;\r\n      if (tableState.sort.predicate) {\r\n        filtered = orderBy(filtered, tableState.sort.predicate, tableState.sort.reverse);\r\n      }\r\n      pagination.totalItemCount = filtered.length;\r\n      if (pagination.number !== undefined) {\r\n        pagination.numberOfPages = filtered.length > 0 ? Math.ceil(filtered.length / pagination.number) : 1;\r\n        pagination.start = pagination.start >= filtered.length ? (pagination.numberOfPages - 1) * pagination.number : pagination.start;\r\n        output = filtered.slice(pagination.start, pagination.start + parseInt(pagination.number));\r\n      }\r\n      displaySetter($scope, output || filtered);\r\n    };\r\n\r\n    /**\r\n     * select a dataRow (it will add the attribute isSelected to the row object) or extend selection\r\n     * Extension means that the state of the last row that was selected is extended through to the currently\r\n     * selected row, so all in between will either be selected or deselected. If there was no previously\r\n     * selected row, extend will just select the current row.\r\n     * @param {Object} row - the row to select\r\n     * @param {String} [mode] - \"single\" or \"multiple\" or \"multiple2\" (multiple by default).\r\n     * Multiple2 selects multiple rows only if CTRL or SHIFT key has been pressed. A click without any key pressed\r\n     * deselects all rows expect the one that has been clicked.\r\n     * @param {Number} [key] - presses keyboard key. SHIFT=1, CTRL=2. Works only in \"multiple\" mode\r\n     */\r\n    this.select = function select (row, mode, key) {\r\n\r\n      function shiftSelect(row, index) {\r\n        var lastIndex = rows.indexOf(lastSelected);\r\n        var state = lastSelected.isSelected;\r\n        var min = Math.min(lastIndex, index);\r\n        var max = Math.max(lastIndex, index);\r\n        for(var i = min; i <= max; i++)\r\n          rows[i].isSelected = state;\r\n        lastSelected = row;\r\n      }\r\n\r\n      function multiSelect(row, index) {\r\n        rows[index].isSelected = !rows[index].isSelected;\r\n        lastSelected = row;\r\n      }\r\n\r\n      var rows = copyRefs(displayGetter($scope));\r\n      var index = rows.indexOf(row);\r\n      if (index !== -1) {\r\n        if (mode === 'single') {\r\n          row.isSelected = row.isSelected !== true;\r\n          if (lastSelected) {\r\n            lastSelected.isSelected = false;\r\n          }\r\n          lastSelected = row.isSelected === true ? row : undefined;\r\n        }\r\n        else if (mode === 'multiple2') {\r\n          if(key === 1 && lastSelected) {\r\n            shiftSelect(row, index);\r\n          }\r\n          else if (key === 2) {\r\n            multiSelect(row, index);\r\n          }\r\n          else {\r\n            for(var i = 0; i < rows.length; i++) {\r\n              rows[i].isSelected = false\r\n            }\r\n            row.isSelected = row.isSelected !== true;\r\n            lastSelected = row.isSelected === true ? row : undefined;\r\n          }\r\n        }\r\n        else {\r\n          if(key === 1 && lastSelected) {\r\n            shiftSelect(row, index);\r\n          } else {\r\n            multiSelect(row, index);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    /**\r\n     * select or de-select all rows.\r\n     * @param {Collection} rows - The array of rows to select or deselect\r\n     * @param {Boolean} state - The target state. If falsey, selectionUsed will also be reset\r\n     */\r\n    this.selectAll = function selectAll (rows, state) {\r\n    \tfor(var i = 0; i < rows.length; i++)\r\n    \t\trows[i].isSelected = state;\r\n    \tif(!state)\r\n    \t\tlastSelected = undefined;\r\n    } \r\n\r\n    /**\r\n     * take a slice of the current sorted/filtered collection (pagination)\r\n     *\r\n     * @param {Number} start - start index of the slice\r\n     * @param {Number} number - the number of item in the slice\r\n     */\r\n    this.slice = function splice (start, number) {\r\n      tableState.pagination.start = start;\r\n      tableState.pagination.number = number;\r\n      return this.pipe();\r\n    };\r\n\r\n    /**\r\n     * return the current state of the table\r\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\r\n     */\r\n    this.tableState = function getTableState () {\r\n      return tableState;\r\n    };\r\n\r\n    this.getFilteredCollection = function getFilteredCollection () {\r\n      return filtered || safeCopy;\r\n    };\r\n\r\n    /**\r\n     * Use a different filter function than the angular FilterFilter\r\n     * @param filterName the name under which the custom filter is registered\r\n     */\r\n    this.setFilterFunction = function setFilterFunction (filterName) {\r\n      filter = $filter(filterName);\r\n    };\r\n\r\n    /**\r\n     * Use a different function than the angular orderBy\r\n     * @param sortFunctionName the name under which the custom order function is registered\r\n     */\r\n    this.setSortFunction = function setSortFunction (sortFunctionName) {\r\n      orderBy = $filter(sortFunctionName);\r\n    };\r\n\r\n    /**\r\n     * Usually when the safe copy is updated the pipe function is called.\r\n     * Calling this method will prevent it, which is something required when using a custom pipe function\r\n     */\r\n    this.preventPipeOnWatch = function preventPipe () {\r\n      pipeAfterSafeCopy = false;\r\n    };\r\n  }])\r\n  .directive('stTable', function () {\r\n    return {\r\n      restrict: 'A',\r\n      controller: 'stTableController',\r\n      link: function (scope, element, attr, ctrl) {\r\n\r\n        if (attr.stSetFilter) {\r\n          ctrl.setFilterFunction(attr.stSetFilter);\r\n        }\r\n\r\n        if (attr.stSetSort) {\r\n          ctrl.setSortFunction(attr.stSetSort);\r\n        }\r\n      }\r\n    };\r\n  });\r\n\nng.module('smart-table')\r\n  .directive('stSearch', ['stConfig', '$timeout','$parse', function (stConfig, $timeout, $parse) {\r\n    return {\r\n      require: '^stTable',\r\n      link: function (scope, element, attr, ctrl) {\r\n        var tableCtrl = ctrl;\r\n        var promise = null;\r\n        var throttle = attr.stDelay || stConfig.search.delay;\r\n        var event = attr.stInputEvent || stConfig.search.inputEvent;\r\n\r\n        attr.$observe('stSearch', function (newValue, oldValue) {\r\n          var input = element[0].value;\r\n          if (newValue !== oldValue && input) {\r\n            ctrl.tableState().search = {};\r\n            tableCtrl.search(input, newValue);\r\n          }\r\n        });\r\n\r\n        //table state -> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().search;\r\n        }, function (newValue, oldValue) {\r\n          var predicateExpression = attr.stSearch || '$';\r\n          if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {\r\n            element[0].value = $parse(predicateExpression)(newValue.predicateObject) || '';\r\n          }\r\n        }, true);\r\n\r\n        // view -> table state\r\n        element.bind(event, function (evt) {\r\n          evt = evt.originalEvent || evt;\r\n          if (promise !== null) {\r\n            $timeout.cancel(promise);\r\n          }\r\n\r\n          promise = $timeout(function () {\r\n            tableCtrl.search(evt.target.value, attr.stSearch || '');\r\n            promise = null;\r\n          }, throttle);\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stSelectRow', ['stConfig', function (stConfig) {\r\n    return {\r\n      restrict: 'A',\r\n      require: '^stTable',\r\n      scope: {\r\n        row: '=stSelectRow'\r\n      },\r\n      link: function (scope, element, attr, ctrl) {\r\n        var mode = attr.stSelectMode || stConfig.select.mode;\r\n        element.bind('click', function ($event) {\r\n          scope.$apply(function () {\r\n            ctrl.select(scope.row, mode, $event.shiftKey ? 1 : ($event.ctrlKey ? 2 : 0));\r\n          });\r\n        });\r\n\r\n        scope.$watch('row.isSelected', function (newValue) {\r\n          if (newValue === true) {\r\n            element.addClass(stConfig.select.selectedClass);\r\n          } else {\r\n            element.removeClass(stConfig.select.selectedClass);\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }])\r\n  .directive('stSelectRowCtrl', ['stConfig', function (stConfig) {\r\n    return {\r\n      restrict: 'A',\r\n      require: '^stTable',\r\n      scope: {\r\n        row: '=stSelectRowCtrl'\r\n      },\r\n      link: function (scope, element, attr, ctrl) {\r\n        var mode = attr.stSelectMode || stConfig.select.mode;\r\n        if (mode == 'multiple2') {\r\n          element.bind('click', function ($event) {\r\n            $event.stopPropagation();\r\n            scope.$apply(function () {\r\n              ctrl.select(scope.row, mode, 2);\r\n             });\r\n          });\r\n\r\n          scope.$watch('row.isSelected', function (newValue) {\r\n            if (newValue === true) {\r\n              element.addClass(stConfig.select.selectedClass);\r\n            } else {\r\n              element.removeClass(stConfig.select.selectedClass);\r\n            }\r\n          });\r\n        }\r\n\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\r\n    return {\r\n      restrict: 'A',\r\n      require: '^stTable',\r\n      link: function (scope, element, attr, ctrl) {\r\n\r\n        var predicate = attr.stSort;\r\n        var getter = $parse(predicate);\r\n        var index = 0;\r\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\r\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\r\n        var stateClasses = [classAscent, classDescent];\r\n        var sortDefault;\r\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\r\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\r\n        var promise = null;\r\n        var throttle = attr.stDelay || stConfig.sort.delay;\r\n\r\n        if (attr.stSortDefault) {\r\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\r\n        }\r\n\r\n        //view --> table state\r\n        function sort () {\r\n          if (descendingFirst) {\r\n            index = index === 0 ? 2 : index - 1;\r\n          } else {\r\n            index++;\r\n          }\r\n\r\n          var func;\r\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\r\n          if (index % 3 === 0 && !!skipNatural !== true) {\r\n            //manual reset\r\n            index = 0;\r\n            ctrl.tableState().sort = {};\r\n            ctrl.tableState().pagination.start = 0;\r\n            func = ctrl.pipe.bind(ctrl);\r\n          } else {\r\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\r\n          }\r\n          if (promise !== null) {\r\n            $timeout.cancel(promise);\r\n          }\r\n          if (throttle < 0) {\r\n            func();\r\n          } else {\r\n            promise = $timeout(func, throttle);\r\n          }\r\n        }\r\n\r\n        element.bind('click', function sortClick () {\r\n          if (predicate) {\r\n            scope.$apply(sort);\r\n          }\r\n        });\r\n\r\n        if (sortDefault) {\r\n          index = sortDefault === 'reverse' ? 1 : 0;\r\n          sort();\r\n        }\r\n\r\n        //table state --> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().sort;\r\n        }, function (newValue) {\r\n          if (newValue.predicate !== predicate) {\r\n            index = 0;\r\n            element\r\n              .removeClass(classAscent)\r\n              .removeClass(classDescent);\r\n          } else {\r\n            index = newValue.reverse === true ? 2 : 1;\r\n            element\r\n              .removeClass(stateClasses[index % 2])\r\n              .addClass(stateClasses[index - 1]);\r\n          }\r\n        }, true);\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stPagination', ['stConfig', function (stConfig) {\r\n    return {\r\n      restrict: 'EA',\r\n      require: '^stTable',\r\n      scope: {\r\n        stItemsByPage: '=?',\r\n        stDisplayedPages: '=?',\r\n        stPageChange: '&'\r\n      },\r\n      templateUrl: function (element, attrs) {\r\n        if (attrs.stTemplate) {\r\n          return attrs.stTemplate;\r\n        }\r\n        return stConfig.pagination.template;\r\n      },\r\n      link: function (scope, element, attrs, ctrl) {\r\n\r\n        scope.stItemsByPage = scope.stItemsByPage ? +(scope.stItemsByPage) : stConfig.pagination.itemsByPage;\r\n        scope.stDisplayedPages = scope.stDisplayedPages ? +(scope.stDisplayedPages) : stConfig.pagination.displayedPages;\r\n\r\n        scope.currentPage = 1;\r\n        scope.pages = [];\r\n\r\n        function redraw () {\r\n          var paginationState = ctrl.tableState().pagination;\r\n          var start = 1;\r\n          var end;\r\n          var i;\r\n          var prevPage = scope.currentPage;\r\n          scope.totalItemCount = paginationState.totalItemCount;\r\n          scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;\r\n\r\n          start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));\r\n          end = start + scope.stDisplayedPages;\r\n\r\n          if (end > paginationState.numberOfPages) {\r\n            end = paginationState.numberOfPages + 1;\r\n            start = Math.max(1, end - scope.stDisplayedPages);\r\n          }\r\n\r\n          scope.pages = [];\r\n          scope.numPages = paginationState.numberOfPages;\r\n\r\n          for (i = start; i < end; i++) {\r\n            scope.pages.push(i);\r\n          }\r\n\r\n          if (prevPage !== scope.currentPage) {\r\n            scope.stPageChange({newPage: scope.currentPage});\r\n          }\r\n        }\r\n\r\n        //table state --> view\r\n        scope.$watch(function () {\r\n          return ctrl.tableState().pagination;\r\n        }, redraw, true);\r\n\r\n        //scope --> table state  (--> view)\r\n        scope.$watch('stItemsByPage', function (newValue, oldValue) {\r\n          if (newValue !== oldValue) {\r\n            scope.selectPage(1);\r\n          }\r\n        });\r\n\r\n        scope.$watch('stDisplayedPages', redraw);\r\n\r\n        //view -> table state\r\n        scope.selectPage = function (page) {\r\n          if (page > 0 && page <= scope.numPages) {\r\n            ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);\r\n          }\r\n        };\r\n\r\n        if (!ctrl.tableState().pagination.number) {\r\n          ctrl.slice(0, scope.stItemsByPage);\r\n        }\r\n      }\r\n    };\r\n  }]);\r\n\nng.module('smart-table')\r\n  .directive('stPipe', ['stConfig', '$timeout', function (config, $timeout) {\r\n    return {\r\n      require: 'stTable',\r\n      scope: {\r\n        stPipe: '='\r\n      },\r\n      link: {\r\n\r\n        pre: function (scope, element, attrs, ctrl) {\r\n\r\n          var pipePromise = null;\r\n\r\n          if (ng.isFunction(scope.stPipe)) {\r\n            ctrl.preventPipeOnWatch();\r\n            ctrl.pipe = function () {\r\n\r\n              if (pipePromise !== null) {\r\n                $timeout.cancel(pipePromise)\r\n              }\r\n\r\n              pipePromise = $timeout(function () {\r\n                scope.stPipe(ctrl.tableState(), ctrl);\r\n              }, config.pipe.delay);\r\n\r\n              return pipePromise;\r\n            }\r\n          }\r\n        },\r\n\r\n        post: function (scope, element, attrs, ctrl) {\r\n          ctrl.pipe();\r\n        }\r\n      }\r\n    };\r\n  }]);\r\n\n})(angular);"]}